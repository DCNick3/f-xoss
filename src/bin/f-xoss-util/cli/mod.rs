mod device;
mod setup;

use crate::config;
use crate::config::XossUtilConfig;
use anyhow::{Context, Result};
use camino::Utf8PathBuf;
use clap::{Args, CommandFactory, Parser, Subcommand};
use clap_complete::Shell;
use prettytable::table;
use std::ops::Deref;
use tracing::info;

#[derive(Parser, Debug)]
#[command(name = "f-xoss-util", author, version, about, long_about = None)]
/// An utility to interact with the Xoss NAV bike computer
pub struct Cli {
    #[clap(subcommand)]
    pub command: CliCommand,
}

#[derive(Args, Debug)]
pub struct SetupCli {}

#[derive(Args, Debug)]
pub struct MgaUpdateOptions {
    /// Do not try to update the MGA data
    ///
    /// May be useful if you have no Internet Connection
    #[clap(long)]
    pub mga_offline: bool,
    /// Force update of the MGA data
    #[clap(long)]
    pub mga_force_update: bool,
}

#[derive(Args, Debug)]
pub struct SyncOptions {
    #[clap(flatten)]
    mga_update: MgaUpdateOptions,
}

#[derive(Subcommand, Debug)]
pub enum DeviceCommand {
    /// Synchronize the device with the computer.
    ///
    /// Set the time, upload new MGA (satellite) data, download tracks
    Sync(SyncOptions),
    /// Shows various information about the device.
    Info,
    /// Download a file from the device.
    Pull {
        device_filename: String,
        output_filename: Option<Utf8PathBuf>,
    },
    /// Upload a file to the device.
    Push {
        input_filename: Utf8PathBuf,
        device_filename: Option<String>,
    },
    /// Delete a file from the device.
    ///
    /// NOTE: don't delete .json files, not all of them are regenerated by the device.
    Delete { device_filename: String },
}

#[derive(Args, Debug)]
pub struct DeviceCli {
    // TODO: include options for selecting the device
    #[clap(subcommand)]
    subcommand: DeviceCommand,
}

#[derive(clap::Args, Debug)]
pub struct GenerateCli {
    /// The shell to generate the completion for
    #[clap(value_enum)]
    shell: Shell,
}

#[derive(Subcommand, Debug)]
pub enum CliCommand {
    /// Generate a config file to be used with the other commands.
    Setup(SetupCli),
    /// Print paths to the config file and the data directory.
    Paths,
    /// Interact with the device.
    Dev(DeviceCli),
    /// Make sure the MGA data is up to date.
    UpdateMga(MgaUpdateOptions),
    /// Generate shell completion
    Completion(GenerateCli),
}

impl Cli {
    pub async fn run(self, config: Option<XossUtilConfig>) -> Result<()> {
        match self.command {
            CliCommand::Setup(setup) => setup
                .run(config)
                .await
                .context("Failed to run the setup subcommand"),
            CliCommand::Paths => {
                let app_dirs = config::APP_DIRS.deref();

                let mut table = table![
                    ["Config file:", config::config_path().display()],
                    ["Data directory:", app_dirs.data_dir().display()],
                    ["Cache directory:", app_dirs.cache_dir().display()]
                ];
                table.set_format(*prettytable::format::consts::FORMAT_CLEAN);

                info!("Paths:\n{}", table);

                Ok(())
            }
            CliCommand::Dev(dev) => {
                let device = crate::locate_util::find_device_from_config(&config)
                    .await
                    .context("Failed to find the device")?;

                let result = dev.run(&device, config).await;

                // let disconnect_result = device
                //     .disconnect()
                //     .await
                //     .context("Failed to disconnect from the device");

                result.context("Failed to run the device subcommand")
                // .and(disconnect_result)
            }
            CliCommand::UpdateMga(mga_update) => {
                let config = config.context("Config is required for update-mga subcommand")?;
                crate::mga::get_mga_data(&config.mga, &mga_update).await?;
                Ok(())
            }
            CliCommand::Completion(generate) => {
                let mut cmd = Cli::command();
                let bin_name = cmd.get_name().to_string();
                clap_complete::generate(generate.shell, &mut cmd, bin_name, &mut std::io::stdout());
                Ok(())
            }
        }
    }
}
